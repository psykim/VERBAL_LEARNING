<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>언어 학습 검사 통합 분석 프로그램</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .card-header {
            padding: 20px;
            border-bottom: 1px solid #e5e5e5;
        }

        .card-title {
            font-size: 24px;
            font-weight: 600;
        }

        .card-content {
            padding: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #555;
        }

        input[type="number"], select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }

        .grid {
            display: grid;
            gap: 16px;
        }

        .grid-cols-3 {
            grid-template-columns: repeat(3, 1fr);
        }

        .grid-cols-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .word-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 12px;
            background: #f9f9f9;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
        }

        .word-grid.cols-5 {
            grid-template-columns: repeat(5, 1fr);
        }

        .word-grid.cols-3 {
            grid-template-columns: repeat(3, 1fr);
        }

        .word-checkbox {
            display: flex;
            align-items: center;
            font-size: 14px;
        }

        .word-checkbox input {
            margin-right: 4px;
            width: 16px;
            height: 16px;
        }

        .trial-section {
            margin-bottom: 24px;
        }

        .trial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .trial-label {
            font-weight: 500;
        }

        .trial-count {
            font-size: 14px;
            color: #666;
        }

        .button {
            background: #3b82f6;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            width: 100%;
            transition: background 0.2s;
        }

        .button:hover {
            background: #2563eb;
        }

        .results-section {
            margin-top: 24px;
        }

        .results-header {
            background: #f9f9f9;
            padding: 16px;
            border-radius: 4px;
            margin-bottom: 16px;
        }

        .results-category {
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .results-category h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .results-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
        }

        .results-label {
            color: #666;
        }

        .results-value {
            font-weight: 500;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .interference-section {
            background: #f0f9ff;
            padding: 16px;
            border-radius: 4px;
            margin-bottom: 16px;
        }

        .fcsrt-trial {
            border: 1px solid #e5e5e5;
            padding: 16px;
            border-radius: 4px;
            margin-bottom: 16px;
        }

        @media (max-width: 768px) {
            .grid-cols-3 {
                grid-template-columns: 1fr;
            }

            .grid-cols-2 {
                grid-template-columns: 1fr;
            }

            .word-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header">
                <h1 class="card-title">언어 학습 검사 통합 분석 프로그램</h1>
            </div>
            <div class="card-content">
                <div class="form-group">
                    <label>검사 선택</label>
                    <select id="testSelect">
                        <option value="">검사를 선택하세요</option>
                        <option value="CVLT-3">California Verbal Learning Test-3</option>
                        <option value="K-CVLT">Korean California Verbal Learning Test</option>
                        <option value="RAVLT">Rey Auditory Verbal Learning Test</option>
                        <option value="HVLT-R">Hopkins Verbal Learning Test-Revised</option>
                        <option value="SVLT">Seoul Verbal Learning Test</option>
                        <option value="CERAD">CERAD Word List Memory Test</option>
                        <option value="SRT">Selective Reminding Test</option>
                        <option value="FCSRT">Free and Cued Selective Reminding Test</option>
                    </select>
                </div>

                <div id="testForm"></div>

                <button id="analyzeBtn" class="button" style="display: none;">결과 분석</button>
            </div>
        </div>

        <div id="resultsContainer"></div>
    </div>

    <script>
        // 검사별 단어 목록
        const testWordLists = {
            'CVLT-3': {
                listA: {
                    words: ['drill', 'vest', 'peach', 'truck', 'plum', 'helmet', 'apple', 'bus', 
                            'chisel', 'apricot', 'jacket', 'airplane', 'pliers', 'boots', 'tangerine', 'bicycle'],
                    categories: {
                        'drill': 'tools', 'vest': 'clothes', 'peach': 'fruits', 'truck': 'vehicles',
                        'plum': 'fruits', 'helmet': 'clothes', 'apple': 'fruits', 'bus': 'vehicles',
                        'chisel': 'tools', 'apricot': 'fruits', 'jacket': 'clothes', 'airplane': 'vehicles',
                        'pliers': 'tools', 'boots': 'clothes', 'tangerine': 'fruits', 'bicycle': 'vehicles'
                    }
                },
                listB: {
                    words: ['shovel', 'orange', 'shirt', 'hammer', 'banana', 'coat', 'saw', 'strawberry'],
                    categories: {}
                }
            },
            'K-CVLT': {
                listA: {
                    words: ['사과', '망치', '바지', '버스', '포도', '톱', '셔츠', '자전거',
                            '딸기', '드라이버', '양말', '기차', '오렌지', '못', '모자', '비행기'],
                    categories: {
                        '사과': '과일', '망치': '도구', '바지': '의류', '버스': '탈것',
                        '포도': '과일', '톱': '도구', '셔츠': '의류', '자전거': '탈것',
                        '딸기': '과일', '드라이버': '도구', '양말': '의류', '기차': '탈것',
                        '오렌지': '과일', '못': '도구', '모자': '의류', '비행기': '탈것'
                    }
                },
                listB: {
                    words: ['의자', '침대', '책상', '소파', '탁자', '서랍장', '옷장', '책장'],
                    categories: {}
                }
            },
            'RAVLT': {
                listA: {
                    words: ['drum', 'curtain', 'bell', 'coffee', 'school', 'parent', 'moon', 'garden',
                            'hat', 'farmer', 'nose', 'turkey', 'color', 'house', 'river'],
                    categories: {}
                },
                listB: {
                    words: ['desk', 'ranger', 'bird', 'shoe', 'stove', 'mountain', 'glasses', 'towel',
                            'cloud', 'boat', 'lamb', 'gun', 'pencil', 'church', 'fish'],
                    categories: {}
                }
            },
            'HVLT-R': {
                form1: {
                    words: ['emerald', 'horse', 'cabin', 'sapphire', 'cave', 'cow', 'pearl', 'tent',
                            'tiger', 'ruby', 'hotel', 'lion'],
                    categories: {
                        'emerald': 'stones', 'horse': 'animals', 'cabin': 'dwellings', 'sapphire': 'stones',
                        'cave': 'dwellings', 'cow': 'animals', 'pearl': 'stones', 'tent': 'dwellings',
                        'tiger': 'animals', 'ruby': 'stones', 'hotel': 'dwellings', 'lion': 'animals'
                    }
                }
            },
            'SVLT': {
                listA: {
                    words: ['장미', '소파', '호랑이', '국화', '책상', '사자', '백합', '의자',
                            '코끼리', '튤립', '침대', '기린'],
                    categories: {
                        '장미': '꽃', '소파': '가구', '호랑이': '동물', '국화': '꽃',
                        '책상': '가구', '사자': '동물', '백합': '꽃', '의자': '가구',
                        '코끼리': '동물', '튤립': '꽃', '침대': '가구', '기린': '동물'
                    }
                },
                listB: {
                    words: ['자동차', '버스', '기차', '배', '비행기', '자전거'],
                    categories: {}
                }
            },
            'CERAD': {
                words: ['butter', 'arm', 'shore', 'letter', 'queen', 'cabin', 'pole', 'ticket', 'grass', 'engine'],
                categories: {}
            },
            'FCSRT': {
                words: ['grapes', 'vest', 'horse', 'desk', 'strawberry', 'coat', 'lion', 'chair',
                        'orange', 'pants', 'cow', 'bed', 'apple', 'shirt', 'cat', 'sofa'],
                categories: {
                    'grapes': 'fruit', 'vest': 'clothing', 'horse': 'animal', 'desk': 'furniture',
                    'strawberry': 'fruit', 'coat': 'clothing', 'lion': 'animal', 'chair': 'furniture',
                    'orange': 'fruit', 'pants': 'clothing', 'cow': 'animal', 'bed': 'furniture',
                    'apple': 'fruit', 'shirt': 'clothing', 'cat': 'animal', 'sofa': 'furniture'
                }
            }
        };

        // CVLT 연령별 규준
        const cvltNorms = {
            '16-29': {
                trial1: { mean: 7.5, sd: 2.1 },
                trial5: { mean: 13.8, sd: 1.9 },
                totalLearning: { mean: 54.2, sd: 8.3 },
                delayedFree: { mean: 12.1, sd: 2.5 },
                delayedCued: { mean: 13.2, sd: 2.1 },
                recognition: { mean: 15.3, sd: 0.9 }
            },
            '30-44': {
                trial1: { mean: 6.9, sd: 2.0 },
                trial5: { mean: 12.9, sd: 2.1 },
                totalLearning: { mean: 50.8, sd: 8.9 },
                delayedFree: { mean: 11.2, sd: 2.8 },
                delayedCued: { mean: 12.4, sd: 2.3 },
                recognition: { mean: 15.1, sd: 1.0 }
            },
            '45-59': {
                trial1: { mean: 6.3, sd: 1.9 },
                trial5: { mean: 11.8, sd: 2.3 },
                totalLearning: { mean: 46.5, sd: 9.2 },
                delayedFree: { mean: 10.1, sd: 3.0 },
                delayedCued: { mean: 11.3, sd: 2.6 },
                recognition: { mean: 14.8, sd: 1.2 }
            },
            '60-89': {
                trial1: { mean: 5.2, sd: 1.8 },
                trial5: { mean: 9.8, sd: 2.5 },
                totalLearning: { mean: 38.4, sd: 9.8 },
                delayedFree: { mean: 7.9, sd: 3.2 },
                delayedCued: { mean: 9.1, sd: 3.0 },
                recognition: { mean: 14.2, sd: 1.5 }
            }
        };

        let selectedTest = '';
        let testData = {};

        // 공통 필드 생성
        function createCommonFields() {
            return `
                <div class="grid grid-cols-3">
                    <div class="form-group">
                        <label>연령</label>
                        <input type="number" id="age" placeholder="나이를 입력하세요">
                    </div>
                    <div class="form-group">
                        <label>교육년수</label>
                        <input type="number" id="education" placeholder="교육년수를 입력하세요">
                    </div>
                    <div class="form-group">
                        <label>성별</label>
                        <select id="gender">
                            <option value="">선택</option>
                            <option value="M">남</option>
                            <option value="F">여</option>
                        </select>
                    </div>
                </div>
            `;
        }

        // 단어 그리드 생성
        function createWordGrid(words, trialName, columns = 4) {
            const gridClass = columns === 5 ? 'cols-5' : columns === 3 ? 'cols-3' : '';
            let html = `<div class="word-grid ${gridClass}">`;
            
            words.forEach((word, index) => {
                html += `
                    <label class="word-checkbox">
                        <input type="checkbox" data-trial="${trialName}" data-word="${word}">
                        <span>${word}</span>
                    </label>
                `;
            });
            
            html += '</div>';
            return html;
        }

        // 의미적 군집 계산
        function calculateSemanticClustering(words, categories) {
            if (!words || words.length < 2 || !categories) return { score: 0, clusters: 0 };
            
            let score = 0;
            let clusters = 0;
            let consecutive = 1;
            
            for (let i = 1; i < words.length; i++) {
                const prevCategory = categories[words[i-1]];
                const currCategory = categories[words[i]];
                
                if (prevCategory && currCategory && prevCategory === currCategory) {
                    consecutive++;
                } else {
                    if (consecutive >= 2) {
                        score += (consecutive - 1);
                        clusters++;
                    }
                    consecutive = 1;
                }
            }
            
            if (consecutive >= 2) {
                score += (consecutive - 1);
                clusters++;
            }
            
            return { score, clusters };
        }

        // 계열적 군집 계산
        function calculateSerialClustering(recalledWords, originalOrder) {
            if (!recalledWords || recalledWords.length < 2) return { score: 0, clusters: 0 };
            
            let score = 0;
            let clusters = 0;
            let consecutive = 1;
            
            for (let i = 1; i < recalledWords.length; i++) {
                const prevIndex = originalOrder.indexOf(recalledWords[i-1]);
                const currIndex = originalOrder.indexOf(recalledWords[i]);
                
                if (prevIndex !== -1 && currIndex !== -1 && currIndex === prevIndex + 1) {
                    consecutive++;
                } else {
                    if (consecutive >= 2) {
                        score += (consecutive - 1);
                        clusters++;
                    }
                    consecutive = 1;
                }
            }
            
            if (consecutive >= 2) {
                score += (consecutive - 1);
                clusters++;
            }
            
            return { score, clusters };
        }

        // 학습 일관성 계산
        function calculateConsistency(trials) {
            const validTrials = trials.filter(t => t && t.length > 0);
            if (validTrials.length < 2) return 0;
            
            let sharedWords = 0;
            let totalWords = 0;
            
            for (let i = 0; i < validTrials.length - 1; i++) {
                const current = new Set(validTrials[i]);
                const next = new Set(validTrials[i + 1]);
                
                const shared = [...current].filter(word => next.has(word)).length;
                sharedWords += shared;
                totalWords += current.size;
            }
            
            return totalWords > 0 ? (sharedWords / totalWords * 100) : 0;
        }

        // 침입 오류 감지
        function detectIntrusions(recalledWords, validWords) {
            const validSet = new Set(validWords);
            return recalledWords.filter(word => !validSet.has(word));
        }

        // 반복 오류 감지
        function detectRepetitions(recalledWords) {
            const seen = new Set();
            const repetitions = [];
            
            recalledWords.forEach(word => {
                if (seen.has(word)) {
                    repetitions.push(word);
                }
                seen.add(word);
            });
            
            return repetitions;
        }

        // T점수 계산
        function calculateTScore(rawScore, mean, sd) {
            if (!mean || !sd || sd === 0) return null;
            return Math.round(50 + 10 * ((rawScore - mean) / sd));
        }

        // 연령대 결정
        function getAgeGroup(age) {
            const ageNum = parseInt(age);
            if (ageNum >= 16 && ageNum <= 29) return '16-29';
            if (ageNum >= 30 && ageNum <= 44) return '30-44';
            if (ageNum >= 45 && ageNum <= 59) return '45-59';
            if (ageNum >= 60 && ageNum <= 89) return '60-89';
            return null;
        }

        // 계열 위치 효과 계산
        function calculateSerialPositionEffect(trials, originalWords) {
            const positions = originalWords.length;
            const recallByPosition = new Array(positions).fill(0);
            const totalTrials = trials.filter(t => t && t.length > 0).length;
            
            trials.forEach(trial => {
                if (trial && trial.length > 0) {
                    trial.forEach(word => {
                        const position = originalWords.indexOf(word);
                        if (position !== -1) {
                            recallByPosition[position]++;
                        }
                    });
                }
            });
            
            const primacyPositions = Math.floor(positions / 3);
            const recencyPositions = Math.floor(positions / 3);
            const middleStart = primacyPositions;
            const middleEnd = positions - recencyPositions;
            
            const primacy = recallByPosition.slice(0, primacyPositions).reduce((a, b) => a + b, 0) / (primacyPositions * totalTrials);
            const middle = recallByPosition.slice(middleStart, middleEnd).reduce((a, b) => a + b, 0) / ((middleEnd - middleStart) * totalTrials);
            const recency = recallByPosition.slice(-recencyPositions).reduce((a, b) => a + b, 0) / (recencyPositions * totalTrials);
            
            return { primacy, middle, recency, recallByPosition };
        }

        // 선택된 단어 수집
        function collectWords(trialName) {
            const checkboxes = document.querySelectorAll(`input[data-trial="${trialName}"]:checked`);
            return Array.from(checkboxes).map(cb => cb.dataset.word);
        }

        // 검사별 폼 생성
        function generateTestForm(test) {
            let formHTML = createCommonFields();
            
            switch(test) {
                case 'CVLT-3':
                case 'K-CVLT':
                    const cvltWords = testWordLists[test];
                    formHTML += `
                        <div class="section-title">List A 학습 시행</div>
                        ${[1, 2, 3, 4, 5].map(trial => `
                            <div class="trial-section">
                                <div class="trial-header">
                                    <span class="trial-label">시행 ${trial}</span>
                                    <span class="trial-count" id="trial${trial}Count">선택: 0/16</span>
                                </div>
                                ${createWordGrid(cvltWords.listA.words, `trial${trial}`)}
                            </div>
                        `).join('')}
                        
                        <div class="interference-section">
                            <div class="section-title">간섭 목록 (List B)</div>
                            <div class="trial-header">
                                <span class="trial-label">List B</span>
                                <span class="trial-count" id="listBCount">선택: 0/8</span>
                            </div>
                            ${createWordGrid(cvltWords.listB.words, 'listB')}
                        </div>
                        
                        <div class="grid grid-cols-2">
                            <div>
                                <div class="section-title">단기 지연 회상</div>
                                <div class="trial-header">
                                    <span class="trial-label">자유 회상</span>
                                    <span class="trial-count" id="shortDelayCount">선택: 0/16</span>
                                </div>
                                ${createWordGrid(cvltWords.listA.words, 'shortDelay')}
                            </div>
                            <div>
                                <div class="section-title">장기 지연 회상</div>
                                <div class="trial-header">
                                    <span class="trial-label">자유 회상</span>
                                    <span class="trial-count" id="longDelayCount">선택: 0/16</span>
                                </div>
                                ${createWordGrid(cvltWords.listA.words, 'longDelay')}
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'RAVLT':
                    const ravltWords = testWordLists.RAVLT;
                    formHTML += `
                        <div class="section-title">List A 학습 시행</div>
                        ${[1, 2, 3, 4, 5].map(trial => `
                            <div class="trial-section">
                                <div class="trial-header">
                                    <span class="trial-label">A${trial}</span>
                                    <span class="trial-count" id="trial${trial}Count">선택: 0/15</span>
                                </div>
                                ${createWordGrid(ravltWords.listA.words, `trial${trial}`, 5)}
                            </div>
                        `).join('')}
                        
                        <div class="interference-section">
                            <div class="section-title">간섭 목록 (List B)</div>
                            <div class="trial-header">
                                <span class="trial-label">B1</span>
                                <span class="trial-count" id="listBCount">선택: 0/15</span>
                            </div>
                            ${createWordGrid(ravltWords.listB.words, 'listB', 5)}
                        </div>
                        
                        <div class="grid grid-cols-2">
                            <div>
                                <div class="section-title">간섭 후 회상</div>
                                <div class="trial-header">
                                    <span class="trial-label">A6</span>
                                    <span class="trial-count" id="a6Count">선택: 0/15</span>
                                </div>
                                ${createWordGrid(ravltWords.listA.words, 'a6', 5)}
                            </div>
                            <div>
                                <div class="section-title">20분 지연 회상</div>
                                <div class="trial-header">
                                    <span class="trial-label">A7</span>
                                    <span class="trial-count" id="a7Count">선택: 0/15</span>
                                </div>
                                ${createWordGrid(ravltWords.listA.words, 'a7', 5)}
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'HVLT-R':
                    const hvltWords = testWordLists['HVLT-R'].form1;
                    formHTML += `
                        <div class="section-title">즉각 회상 시행</div>
                        ${[1, 2, 3].map(trial => `
                            <div class="trial-section">
                                <div class="trial-header">
                                    <span class="trial-label">시행 ${trial}</span>
                                    <span class="trial-count" id="trial${trial}Count">선택: 0/12</span>
                                </div>
                                ${createWordGrid(hvltWords.words, `trial${trial}`)}
                            </div>
                        `).join('')}
                        
                        <div class="section-title">지연 회상 (20-25분)</div>
                        <div class="trial-header">
                            <span class="trial-label">지연 회상</span>
                            <span class="trial-count" id="delayedCount">선택: 0/12</span>
                        </div>
                        ${createWordGrid(hvltWords.words, 'delayed')}
                    `;
                    break;
                    
                case 'CERAD':
                    const ceradWords = testWordLists.CERAD;
                    formHTML += `
                        <div class="section-title">즉각 회상 시행</div>
                        ${[1, 2, 3].map(trial => `
                            <div class="trial-section">
                                <div class="trial-header">
                                    <span class="trial-label">시행 ${trial}</span>
                                    <span class="trial-count" id="trial${trial}Count">선택: 0/10</span>
                                </div>
                                ${createWordGrid(ceradWords.words, `trial${trial}`, 5)}
                            </div>
                        `).join('')}
                        
                        <div class="section-title">지연 회상 (5-10분)</div>
                        <div class="trial-header">
                            <span class="trial-label">지연 회상</span>
                            <span class="trial-count" id="delayedCount">선택: 0/10</span>
                        </div>
                        ${createWordGrid(ceradWords.words, 'delayed', 5)}
                    `;
                    break;
                    
                case 'FCSRT':
                    const fcsrtWords = testWordLists.FCSRT;
                    formHTML += `
                        <div class="section-title">즉각 회상 시행</div>
                        ${[1, 2, 3].map(trial => `
                            <div class="fcsrt-trial">
                                <h4>시행 ${trial}</h4>
                                <div class="grid grid-cols-2">
                                    <div>
                                        <div class="trial-header">
                                            <span class="trial-label">자유 회상</span>
                                            <span class="trial-count" id="fr${trial}Count">선택: 0/16</span>
                                        </div>
                                        ${createWordGrid(fcsrtWords.words, `fr${trial}`)}
                                    </div>
                                    <div>
                                        <div class="trial-header">
                                            <span class="trial-label">단서 회상</span>
                                            <span class="trial-count" id="cr${trial}Count">선택: 0/16</span>
                                        </div>
                                        ${createWordGrid(fcsrtWords.words, `cr${trial}`)}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                        
                        <div class="grid grid-cols-2">
                            <div>
                                <div class="section-title">지연 자유회상 (30분)</div>
                                <div class="trial-header">
                                    <span class="trial-label">자유 회상</span>
                                    <span class="trial-count" id="delayedFreeCount">선택: 0/16</span>
                                </div>
                                ${createWordGrid(fcsrtWords.words, 'delayedFree')}
                            </div>
                            <div>
                                <div class="section-title">지연 단서회상</div>
                                <div class="trial-header">
                                    <span class="trial-label">단서 회상</span>
                                    <span class="trial-count" id="delayedCuedCount">선택: 0/16</span>
                                </div>
                                ${createWordGrid(fcsrtWords.words, 'delayedCued')}
                            </div>
                        </div>
                    `;
                    break;
            }
            
            return formHTML;
        }

        // 체크박스 이벤트 리스너 추가
        function addCheckboxListeners() {
            document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', updateTrialCount);
            });
        }

        // 시행별 선택 수 업데이트
        function updateTrialCount(event) {
            const trial = event.target.dataset.trial;
            const checkedCount = document.querySelectorAll(`input[data-trial="${trial}"]:checked`).length;
            const countElement = document.getElementById(`${trial}Count`);
            
            if (countElement) {
                const maxCount = getMaxCount(trial);
                countElement.textContent = `선택: ${checkedCount}/${maxCount}`;
            }
        }

        // 최대 단어 수 가져오기
        function getMaxCount(trial) {
            const counts = {
                'listB': 8,
                'a6': 15,
                'a7': 15,
                'delayed': selectedTest === 'HVLT-R' ? 12 : 10,
                'delayedFree': 16,
                'delayedCued': 16
            };
            
            if (trial.startsWith('trial')) {
                if (selectedTest === 'RAVLT') return 15;
                if (selectedTest === 'HVLT-R' || selectedTest === 'CERAD') return selectedTest === 'HVLT-R' ? 12 : 10;
                return 16;
            }
            
            if (trial.startsWith('fr') || trial.startsWith('cr')) return 16;
            
            return counts[trial] || 16;
        }

        // 결과 계산
        function calculateResults() {
            const age = document.getElementById('age').value;
            const education = document.getElementById('education').value;
            const gender = document.getElementById('gender').value;
            
            let results = {
                검사명: document.getElementById('testSelect').options[document.getElementById('testSelect').selectedIndex].text,
                연령: age,
                교육년수: education,
                성별: gender
            };
            
            switch(selectedTest) {
                case 'CVLT-3':
                case 'K-CVLT':
                    const cvltResults = calculateCVLTResults();
                    results = { ...results, ...cvltResults };
                    break;
                case 'RAVLT':
                    const ravltResults = calculateRAVLTResults();
                    results = { ...results, ...ravltResults };
                    break;
                case 'HVLT-R':
                    const hvltResults = calculateHVLTResults();
                    results = { ...results, ...hvltResults };
                    break;
                case 'CERAD':
                    const ceradResults = calculateCERADResults();
                    results = { ...results, ...ceradResults };
                    break;
                case 'FCSRT':
                    const fcsrtResults = calculateFCSRTResults();
                    results = { ...results, ...fcsrtResults };
                    break;
            }
            
            displayResults(results);
        }

        // CVLT 결과 계산
        function calculateCVLTResults() {
            const wordList = testWordLists[selectedTest].listA;
            const categories = wordList.categories;
            
            const trials = [
                collectWords('trial1'),
                collectWords('trial2'),
                collectWords('trial3'),
                collectWords('trial4'),
                collectWords('trial5')
            ];
            
            const trial1Score = trials[0].length;
            const trial5Score = trials[4].length;
            const totalLearning = trials.reduce((sum, trial) => sum + trial.length, 0);
            const learningSlope = trial5Score - trial1Score;
            
            const shortDelayFree = collectWords('shortDelay').length;
            const longDelayFree = collectWords('longDelay').length;
            const longDelayCued = longDelayFree + 2; // 임시값
            
            const listBScore = collectWords('listB').length;
            const proactiveInterference = trial1Score ? (listBScore / trial1Score * 100) : 0;
            const retroactiveInterference = trial5Score ? (shortDelayFree / trial5Score * 100) : 0;
            
            const shortRetention = trial5Score ? (shortDelayFree / trial5Score * 100) : 0;
            const longRetention = trial5Score ? (longDelayFree / trial5Score * 100) : 0;
            const cueingBenefit = longDelayCued - longDelayFree;
            
            // 군집 분석
            const semanticResults = trials.map(trial => calculateSemanticClustering(trial, categories));
            const serialResults = trials.map(trial => calculateSerialClustering(trial, wordList.words));
            
            const totalSemanticClusters = semanticResults.reduce((sum, r) => sum + r.clusters, 0);
            const totalSerialClusters = serialResults.reduce((sum, r) => sum + r.clusters, 0);
            const semanticClusterRatio = totalLearning ? (totalSemanticClusters / totalLearning * 100) : 0;
            const serialClusterRatio = totalLearning ? (totalSerialClusters / totalLearning * 100) : 0;
            
            const consistency = calculateConsistency(trials);
            
            // 오류 분석
            let allIntrusions = [];
            let listBIntrusions = 0;
            let totalRepetitions = 0;
            
            trials.forEach((trial, index) => {
                if (trial && trial.length > 0) {
                    const intrusions = detectIntrusions(trial, wordList.words);
                    allIntrusions = [...allIntrusions, ...intrusions];
                    
                    if (index > 0) {
                        const listBWords = testWordLists[selectedTest].listB.words;
                        const bIntrusions = trial.filter(word => listBWords.includes(word));
                        listBIntrusions += bIntrusions.length;
                    }
                    
                    const repetitions = detectRepetitions(trial);
                    totalRepetitions += repetitions.length;
                }
            });
            
            // 계열 위치 효과
            const serialPosition = calculateSerialPositionEffect(trials, wordList.words);
            
            // T점수 계산
            const age = parseInt(document.getElementById('age').value);
            const ageGroup = getAgeGroup(age);
            let tScores = {};
            
            if (ageGroup && cvltNorms[ageGroup]) {
                const norms = cvltNorms[ageGroup];
                tScores = {
                    trial1T: calculateTScore(trial1Score, norms.trial1.mean, norms.trial1.sd),
                    trial5T: calculateTScore(trial5Score, norms.trial5.mean, norms.trial5.sd),
                    totalLearningT: calculateTScore(totalLearning, norms.totalLearning.mean, norms.totalLearning.sd),
                    delayedFreeT: calculateTScore(longDelayFree, norms.delayedFree.mean, norms.delayedFree.sd),
                    delayedCuedT: calculateTScore(longDelayCued, norms.delayedCued.mean, norms.delayedCued.sd),
                };
            }
            
            const immediateMemoryIndex = tScores.totalLearningT || 'N/A';
            const delayedMemoryIndex = (tScores.delayedFreeT && tScores.delayedCuedT) ? 
                Math.round((tScores.delayedFreeT + tScores.delayedCuedT) / 2) : 'N/A';
            
            return {
                '즉각 회상': {
                    '1차 시행': `${trial1Score}/16`,
                    '2차 시행': `${trials[1].length}/16`,
                    '3차 시행': `${trials[2].length}/16`,
                    '4차 시행': `${trials[3].length}/16`,
                    '5차 시행': `${trial5Score}/16`,
                    '총 학습량': `${totalLearning}/80`,
                    '학습 기울기': learningSlope,
                    '학습률': trial1Score ? `${(learningSlope / trial1Score * 100).toFixed(1)}%` : '0%'
                },
                '간섭 효과': {
                    'List B 회상': `${listBScore}/8`,
                    '전향 간섭': `${proactiveInterference.toFixed(1)}%`,
                    '후향 간섭': `${retroactiveInterference.toFixed(1)}%`
                },
                '지연 회상': {
                    '단기 지연 자유회상': `${shortDelayFree}/16`,
                    '장기 지연 자유회상': `${longDelayFree}/16`,
                    '장기 지연 단서회상': `${longDelayCued}/16`,
                    '단기 보유율': `${shortRetention.toFixed(1)}%`,
                    '장기 보유율': `${longRetention.toFixed(1)}%`,
                    '보유율 해석': longRetention < 70 ? '급속 망각 의심' : '정상 범위',
                    '단서 이득': cueingBenefit,
                    '단서 효과 해석': cueingBenefit > 3 ? '인출 결함 시사' : '정상'
                },
                '학습 특성': {
                    '의미적 군집 수': totalSemanticClusters,
                    '의미적 군집 비율': `${semanticClusterRatio.toFixed(1)}%`,
                    '계열적 군집 수': totalSerialClusters,
                    '계열적 군집 비율': `${serialClusterRatio.toFixed(1)}%`,
                    '의미적 > 계열적': totalSemanticClusters > totalSerialClusters ? '예 (효율적)' : '아니오',
                    '학습 일관성': `${consistency.toFixed(1)}%`
                },
                '오류 분석': {
                    '침입 오류 수': allIntrusions.length,
                    '침입 단어': allIntrusions.join(', ') || '없음',
                    'List B 침입': listBIntrusions,
                    '반복 오류 수': totalRepetitions
                },
                '계열 위치 효과': {
                    '초두 효과': `${(serialPosition.primacy * 100).toFixed(1)}%`,
                    '중간 효과': `${(serialPosition.middle * 100).toFixed(1)}%`,
                    '최신 효과': `${(serialPosition.recency * 100).toFixed(1)}%`
                },
                'T점수 (연령 보정)': {
                    '1차 시행 T점수': tScores.trial1T || 'N/A',
                    '5차 시행 T점수': tScores.trial5T || 'N/A',
                    '총 학습 T점수': tScores.totalLearningT || 'N/A',
                    '지연 자유회상 T점수': tScores.delayedFreeT || 'N/A',
                    '지연 단서회상 T점수': tScores.delayedCuedT || 'N/A'
                },
                '학습/기억 지수': {
                    '즉각 기억 지수': immediateMemoryIndex,
                    '지연 기억 지수': delayedMemoryIndex,
                    '재인 기억 지수': 'N/A (재인 데이터 필요)'
                }
            };
        }

        // RAVLT 결과 계산
        function calculateRAVLTResults() {
            const wordList = testWordLists.RAVLT.listA;
            
            const trials = [
                collectWords('trial1'),
                collectWords('trial2'),
                collectWords('trial3'),
                collectWords('trial4'),
                collectWords('trial5')
            ];
            
            const ravltTotal = trials.reduce((sum, trial) => sum + trial.length, 0);
            const ravltSlope = trials[4].length - trials[0].length;
            
            const listBScore = collectWords('listB').length;
            const a6Score = collectWords('a6').length;
            const a7Score = collectWords('a7').length;
            
            const ravltPI = trials[0].length ? (listBScore / trials[0].length * 100) : 0;
            const ravltRI = trials[4].length ? (a6Score / trials[4].length * 100) : 0;
            
            const forgettingRate = trials[4].length ? 
                ((trials[4].length - a7Score) / trials[4].length * 100) : 0;
            
            const ravltConsistency = calculateConsistency(trials);
            const ravltSerialPosition = calculateSerialPositionEffect(trials, wordList.words);
            
            return {
                '학습 단계': {
                    'A1': trials[0].length,
                    'A2': trials[1].length,
                    'A3': trials[2].length,
                    'A4': trials[3].length,
                    'A5': trials[4].length,
                    '총점': ravltTotal,
                    '학습 기울기': ravltSlope
                },
                '간섭 효과': {
                    'B 목록': listBScore,
                    '전향 간섭': ravltPI.toFixed(1) + '%',
                    'A6 (간섭 후)': a6Score,
                    '후향 간섭': ravltRI.toFixed(1) + '%'
                },
                '지연 회상': {
                    'A7 (20분 지연)': a7Score,
                    '망각률': forgettingRate.toFixed(1) + '%',
                    '보유율': (100 - forgettingRate).toFixed(1) + '%'
                },
                '학습 특성': {
                    '학습 일관성': ravltConsistency.toFixed(1) + '%',
                    '초두 효과': (ravltSerialPosition.primacy * 100).toFixed(1) + '%',
                    '중간 효과': (ravltSerialPosition.middle * 100).toFixed(1) + '%',
                    '최신 효과': (ravltSerialPosition.recency * 100).toFixed(1) + '%'
                }
            };
        }

        // HVLT-R 결과 계산
        function calculateHVLTResults() {
            const wordList = testWordLists['HVLT-R'].form1;
            const categories = wordList.categories;
            
            const trials = [
                collectWords('trial1'),
                collectWords('trial2'),
                collectWords('trial3')
            ];
            
            const hvltTotal = trials.reduce((sum, trial) => sum + trial.length, 0);
            const hvltBest = Math.max(...trials.map(t => t.length));
            const delayedScore = collectWords('delayed').length;
            const hvltRetention = hvltBest ? (delayedScore / hvltBest * 100) : 0;
            
            const hvltSemanticScores = trials.map(trial => 
                calculateSemanticClustering(trial, categories).score
            );
            
            const consistency = calculateConsistency(trials);
            
            return {
                '즉각 회상': {
                    '시행 1': trials[0].length,
                    '시행 2': trials[1].length,
                    '시행 3': trials[2].length,
                    '총 회상': hvltTotal,
                    '최고 학습': hvltBest,
                    '학습 곡선': trials[2].length - trials[0].length
                },
                '지연 회상': {
                    '지연 회상': delayedScore,
                    '보유율': hvltRetention.toFixed(1) + '%',
                    '회상 단어': collectWords('delayed').join(', ') || '없음'
                },
                '질적 분석': {
                    '의미적 군집 총점': hvltSemanticScores.reduce((a, b) => a + b, 0),
                    '학습 일관성': consistency.toFixed(1) + '%'
                }
            };
        }

        // CERAD 결과 계산
        function calculateCERADResults() {
            const wordList = { words: testWordLists.CERAD.words };
            
            const trials = [
                collectWords('trial1'),
                collectWords('trial2'),
                collectWords('trial3')
            ];
            
            const ceradTotal = trials.reduce((sum, trial) => sum + trial.length, 0);
            const ceradBest = Math.max(...trials.map(t => t.length));
            const delayedScore = collectWords('delayed').length;
            const savingsScore = ceradBest ? (delayedScore / ceradBest * 100) : 0;
            
            const ceradConsistency = calculateConsistency(trials);
            const ceradSerialPosition = calculateSerialPositionEffect(trials, wordList.words);
            
            return {
                '즉각 회상': {
                    '시행 1': trials[0].length,
                    '시행 2': trials[1].length,
                    '시행 3': trials[2].length,
                    '총점': ceradTotal,
                    '학습': trials[2].length - trials[0].length
                },
                '지연 회상': {
                    '지연 회상': delayedScore,
                    '절약 점수': savingsScore.toFixed(1) + '%',
                    '절약 해석': savingsScore > 90 ? '우수한 고착' : 
                                savingsScore > 70 ? '정상 고착' : 
                                savingsScore > 50 ? '경미한 망각' : '가속 망각'
                },
                '추가 분석': {
                    '학습률': trials[0].length ? 
                        ((trials[2].length - trials[0].length) / trials[0].length * 100).toFixed(1) + '%' : '0%',
                    '학습 일관성': ceradConsistency.toFixed(1) + '%',
                    '초두 효과': (ceradSerialPosition.primacy * 100).toFixed(1) + '%',
                    '최신 효과': (ceradSerialPosition.recency * 100).toFixed(1) + '%'
                }
            };
        }

        // FCSRT 결과 계산
        function calculateFCSRTResults() {
            const frTrials = [
                collectWords('fr1'),
                collectWords('fr2'),
                collectWords('fr3')
            ];
            
            const crTrials = [
                collectWords('cr1'),
                collectWords('cr2'),
                collectWords('cr3')
            ];
            
            const totalFree = frTrials.reduce((sum, trial) => sum + trial.length, 0);
            const totalCued = crTrials.reduce((sum, trial) => sum + trial.length, 0);
            const totalRecall = totalFree + totalCued;
            
            const delayedFree = collectWords('delayedFree').length;
            const delayedCued = collectWords('delayedCued').length;
            
            const encodingSpecificity = (totalRecall / 48 * 100);
            const cuingBenefit = totalFree ? ((totalRecall - totalFree) / totalFree * 100) : 0;
            
            return {
                '즉각 회상': {
                    '자유회상 1': frTrials[0].length,
                    '자유회상 2': frTrials[1].length,
                    '자유회상 3': frTrials[2].length,
                    '총 자유회상': totalFree,
                    '총 단서회상': totalCued,
                    '총 회상': totalRecall + '/48'
                },
                '지연 회상': {
                    '지연 자유회상': delayedFree,
                    '지연 단서회상': delayedCued,
                    '지연 총 회상': delayedFree + delayedCued
                },
                '민감도 지표': {
                    '부호화 특이성 지수': encodingSpecificity.toFixed(1) + '%',
                    '단서 효과': cuingBenefit.toFixed(1) + '%',
                    '보유율': ((delayedFree + delayedCued) / 16 * 100) + '%'
                },
                '진단 해석': {
                    'MCI 가능성': totalFree <= 27 ? '높음' : '낮음',
                    'AD 가능성': totalFree <= 17 ? '매우 높음' : totalRecall <= 40 ? '높음' : '낮음'
                }
            };
        }

        // 결과 표시
        function displayResults(results) {
            let html = `
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">분석 결과</h2>
                    </div>
                    <div class="card-content">
                        <div class="results-header grid grid-cols-3">
                            <div><strong>검사:</strong> ${results.검사명}</div>
                            <div><strong>연령:</strong> ${results.연령}세</div>
                            <div><strong>교육:</strong> ${results.교육년수}년</div>
                        </div>
            `;
            
            Object.entries(results).forEach(([category, values]) => {
                if (['검사명', '연령', '교육년수', '성별'].includes(category)) return;
                
                html += `
                    <div class="results-category">
                        <h3>${category}</h3>
                        <div class="grid grid-cols-2">
                `;
                
                Object.entries(values).forEach(([key, value]) => {
                    html += `
                        <div class="results-item">
                            <span class="results-label">${key}:</span>
                            <span class="results-value">${value}</span>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                </div>
            `;
            
            document.getElementById('resultsContainer').innerHTML = html;
        }

        // 이벤트 리스너
        document.getElementById('testSelect').addEventListener('change', function() {
            selectedTest = this.value;
            const testForm = document.getElementById('testForm');
            const analyzeBtn = document.getElementById('analyzeBtn');
            
            if (selectedTest) {
                testForm.innerHTML = generateTestForm(selectedTest);
                analyzeBtn.style.display = 'block';
                addCheckboxListeners();
            } else {
                testForm.innerHTML = '';
                analyzeBtn.style.display = 'none';
            }
            
            document.getElementById('resultsContainer').innerHTML = '';
        });

        document.getElementById('analyzeBtn').addEventListener('click', calculateResults);
    </script>
</body>
</html>